import random

def generate_maze_recursive_backtracking(aX_size, aY_size):
    walls = [ [[1,1,1,1] for _ in range(aX_size)] for _ in range(aY_size)]
    nodes_visited =  [ [False for _ in range(aX_size)] for _ in range(aY_size)]
    path = [(0,0)] #zasobnik cesty
    x_actual, y_actual = path[0]
    nodes_visited[y_actual][x_actual] = True

    while(path):
        x_actual, y_actual = path[-1] #seber posledni clen z naseho zasobniku cesty, vytahni z nej souradnice
        possible_directions = [] #jde o vektor posunu - (dx1,dy1,w1,w2),(dx2,dy2,w1,w2)... w1-index zdi v soucasne bunce, ktery se odstrani, w2-index zdi v sousedni bunce, ktery se odstrani
        #index zdi (0 vlevo, 1 top, 2 vpravo, 3 dole)
        #maska kvuli rozmerum pole
        if x_actual > 0 and not nodes_visited[y_actual][x_actual - 1]: #hybu se vlevo (dx=-1, dy = 0, )
            possible_directions.append((-1, 0, 0, 2)) #jde o tuple - nemÄ›nitelnou posloupnost hodnot, ktera se da rozbalit
        #jdu smerem doprava
        if x_actual < aX_size - 1 and not nodes_visited[y_actual][x_actual + 1]:
            possible_directions.append((1, 0, 2, 0))
        #jdu nahoru
        if y_actual < aY_size -1 and not nodes_visited[y_actual+1][x_actual]:
            possible_directions.append((0, -1, 1, 3))
        #jdu dolu
        if y_actual > 0 and not nodes_visited[y_actual-1][x_actual]:
            possible_directions.append((0, 1, 3, 1))
        if possible_directions:
            dx, dy, w1, w2 = random.choice(possible_directions)
            x_new, y_new = x_actual + dx, y_actual + dy
            walls[y_actual][x_actual][w1] = 0
            walls[y_new][x_new][w2] = 0
            nodes_visited[y_new][x_new] = True
            path.append((x_new, y_new))
        else:
            path.pop()
    return walls
x_size = 10
y_size = 20
start = (0,0)
end = (x_size-1, y_size-1)
myWalls = generate_maze_recursive_backtracking(x_size, y_size)
print(myWalls)

def draw_maze(aWalls):
    import matplotlib.pyplot as plt
    fig, ax = plt.subplots()
    aY_size = len(aWalls)
    aX_size = len(aWalls[0])
    for y_act in range(aY_size):
        for x_act in range(aX_size):
            left, top, right, bottom = aWalls[y_act][x_act]
            #kreslime cary mezi dvema body
            x0, x1 = x_act, x_act + 1
            y0, y1 = aY_size - y_act, aY_size - (y_act + 1)
            
            if top:
                ax.plot([x0, x1], [y0, y0], color="black")
            if right:
                ax.plot([x1, x1], [y0, y1], color="black")
            if bottom:
                ax.plot([x0, x1], [y1, y1], color="black")
            if left:
                ax.plot([x0, x0], [y0, y1], color="black")
    #ax.set_aspect("equal") #vyrovnani, aby byl ctverec ctvercem
    ax.axis("off") #vypni popisky os
    plt.show()
draw_maze(myWalls)